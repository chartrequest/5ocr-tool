#!/bin/bash
#
# 5ocr_tool v0.3.0
#

#Set some sane defaults
REGION=us-east-2
CONTAINER=web

#Other global variables used in this script:
#CLUSTER: The ECS cluster name
#SERVICE: ECS Service definition service definitions
#CONTAINERNAME: The name of the container
#TASKID: The ECS Task ID
#TID: Short version of the TASKID
#TASKDEF: The full Task definition
#CONFIG_FILE: The Task configuration file S3 URL
#CALLER: The Caller information

usage() {
	echo "Usage:"
	echo "        5ocr-tool login"
        echo "        5ocr-tool logs --environment <environment name> --container web|sidekiq|cron [-f|--follow]"
        echo "        5ocr-tool ssh --environment <environment name> --container web|sidekiq|cron"
        echo "        5ocr-tool config --environment <environment name>"
        echo "        5ocr-tool config:set --environment <environment name> [VAR1=VAL1] [VAR2=] [...]"
        echo "        5ocr-tool db:connect --environment <environment name>"
}

urldecode() {
	: "${*//+/ }"
	echo -e "${_//%/\\x}"
}

do_login() {
	#Configure saml2aws if it has not been configured before
	if [ ! -f ~/.saml2aws ]; then
		saml2aws configure \
		--idp-provider=KeyCloak \
		--url=https://sso.chartrequest.com/auth/realms/ChartRequest/protocol/saml/clients/amazon-aws \
		--mfa=Auto \
		--profile=default \
		--skip-prompt >/dev/null
	fi

	saml2aws script &>/dev/null || saml2aws login --idp-account="default" --disable-keychain
	if [ $? -ne 0 ]; then
		echo "Username/password error, please try again."
		echo "If needed, you may reset your credentials on https://sso.chartrequest.com"
		exit 1
	else
		echo "Login successful, your temporary credentials have been stored"
		echo "in the ~/.aws/credentials file"
		CALLER=$(aws sts get-caller-identity)
	fi
}

check_requisites() {
	if ! hash aws &>/dev/null; then
		echo "This tool requires the aws cli command to run"
		echo "To install it, follow the instructions at https://docs.aws.amazon.com/cli/latest/userguide/install-cliv1.html"
		exit 1
	fi
	if ! hash session-manager-plugin &>/dev/null; then
		echo "This tool requires the aws cli Session Manager Plugin"
		echo "To install it, follow the instructions at https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html#install-plugin-verify"
		exit 1
	fi
	if ! hash saml2aws &>/dev/null; then
		echo "This tool requires the saml2aws script."
		echo "To install it, follow the instructions at https://intranet.chartrequest.com/doku.php?id=development:howtoawskeys"
		exit 1
	fi
	if ! hash ecs-cli &>/dev/null; then
		echo "This tool requires the ecs-cli command."
		echo "To install it, follow the instructions at https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_CLI_installation.html"
		exit 1
	fi
	if ! hash jq &>/dev/null; then
		echo "This tool requires the jq command."
		echo "Install the corresponding system package. On Ubuntu, run 'sudo apt update; sudo apt install jq'"
		exit 1
	fi
	if ! hash psql &>/dev/null; then
		echo "This tool requires the psql command."
		echo "Install the corresponding system package. On Ubuntu, run 'sudo apt update; sudo apt install postgresql'"
		exit 1
	fi
}

check_login() {
	CALLER=$(aws sts get-caller-identity) || do_login
}

get_container_instance_arn() {
	aws ecs describe-tasks \
		--cluster ${CLUSTER} \
		--region ${REGION} \
		--tasks $1 |
	jq -r '.tasks[].containerInstanceArn' || exit 1
}

get_ssm_instance_id() {
	aws ecs describe-container-instances \
		--region ${REGION} \
		--cluster ${CLUSTER} \
		--container-instances $1 |
	jq -r '.containerInstances[].ec2InstanceId' || exit 1
}

get_ssm_instance_address() {
	aws ssm describe-instance-information \
		--region ${REGION} \
		--filters "Key=InstanceIds,Values=$1" | 
	jq -r '.InstanceInformationList[].IPAddress' || exit 1
}

get_caller_identity() {
	echo $CALLER |jq -r '.Arn' || exit 1
}

start_ssh() {
	#From a remote access point of view we can have two environment types
	#EC2/FARGATE environments can be accessed with aws ecs execute-command
	#External environments must be accessed with ssh + docker exec
	#We can look at the environment's task definition to get the environment's type

	local launch_type=$(echo $SERVICE| jq -r '.services[].launchType')
	case "$launch_type" in
		'EXTERNAL')
			#Build the remote username based on the identity we assumed at login time
			u="$(get_caller_identity | sed 's/\(.*\)\/\([^\/]*\)$/\2/')@ad.chartrequest.com"
			# Get the container instance ARN
			CONTAINERINSTANCE=$(get_container_instance_arn ${TASKID})
			# Get the instance ID where the task is running
			INSTANCEID=$(get_ssm_instance_id ${CONTAINERINSTANCE})
			# Get the instance IP Address
			INSTANCEADDRESS=$(get_ssm_instance_address ${INSTANCEID})
			#Get the container name
			CONTAINERID=$(
				ssh -q -tt -l ${u} ${INSTANCEADDRESS} curl -s http://localhost:51678/v1/tasks | \
				jq -r ".Tasks[] | \
					select (.KnownStatus==\"RUNNING\") | \
					select (.Arn==\"${TASKID}\" ) | \
					.Containers[] | \
					select (.Name==\"${CONTAINERNAME}\").DockerName" \
			)
			echo "Containers are running on ${INSTANCEADDRESS}. Logging in..."
                        ssh -tt -l ${u} ${INSTANCEADDRESS} docker exec -ti ${CONTAINERID} /bin/bash
		;;
		'FARGATE'|'EC2')
			aws ecs execute-command \
				--cluster ${CLUSTER} \
				--region ${REGION} \
				--task ${TASKID} \
				--container ${CONTAINERNAME} \
				--interactive \
				--command /bin/bash
		;;
	esac
}

show_logs() {
	ecs-cli logs --region ${REGION} --cluster ${CLUSTER} --task-id ${TID} --container-name ${CONTAINERNAME} ${FOLLOW}
}

get_config() {
	aws s3 cp s3://${CONFIG_FILE} ${1} >/dev/null
	if [ $? -ne 0 ]; then
		echo "Cannot read the configuration file, perhaps you don't have the required permissions"
		exit 1
	fi
}

set_config() {
	local configfile=${1}
	shift 2
	while true; do
		[[ ${1} =~ ^([-_a-zA-Z0-9]*)=(.*)$ ]] && set_option ${configfile} ${BASH_REMATCH[1]} ${BASH_REMATCH[2]}
		shift 1 || break
	done
	aws s3 cp ${configfile} s3://${CONFIG_FILE} >/dev/null
	if [ $? -ne 0 ]; then
		echo "Cannot write the configuration file, perhaps you don't have the required permissions"
		exit 1
	fi
}

set_option() {
	local configfile=${1}
	local variable=${2}
	local value=${3}
	if $(grep -q ${variable} ${configfile}); then
		#The file contains the variable
		if [ "x${value}x" != "xx" ]; then
			#The variable is not empty, so we update it
			escaped_value=$(echo ${value}|sed 's@/@\\/@g')
			sed -i 's/\('${variable}'\)=\(.*\)/\1='${escaped_value}'/' ${configfile}
		else
			#we delete the variable as it is empty
			sed -i '/^'${variable}'/d' ${configfile}
		fi
	else
		#The file doesn't contain the variable so we add it
		echo ${variable}=${value} >> ${configfile}
	fi
}

connect_db() {
	re="^postgresq?l?://([^:]*)(:[^@]*@)([a-zA-Z0-9%\._\-]*)(:?[0-9]*)(/[a-zA-Z0-9_\-]*)\??(.*)$"
	[[ ${1} =~ ${re} ]]
	if [ $? -eq 0 ]; then
		export PGUSER=${BASH_REMATCH[1]}
		export PGPASSWORD=$(echo ${BASH_REMATCH[2]} | sed -e 's/^://' -e 's/@$//')
		export PGHOST=$(urldecode ${BASH_REMATCH[3]})
		export PGPORT=${BASH_REMATCH[4]#:}
		export PGDATABASE=${BASH_REMATCH[5]#/}
		psql
	fi
}

set_environment() {
	local service_arn services deployment_id index task_def_arn servicename
	declare -a service_arns services

	case "${ENVIRONMENT}" in
		'preproduction')
			CLUSTER=preprod
		;;
		staging|testing)
			CLUSTER=cr-do-bangalore
		;;
		*)
			CLUSTER=cr-${ENVIRONMENT}
		;;
	esac

	service_arns=($(aws ecs list-services --cluster ${CLUSTER} --region ${REGION} 2>/dev/null| jq -r '.serviceArns[]'))
	if [ -z "${service_arns[0]}" ]; then 
		echo "Cluster ${CLUSTER} has no running services or you don't have permission to access them"
		exit 1
	fi

	for i in "${service_arns[@]}"; do
		services+=("$(aws ecs describe-services --services ${i} --cluster ${CLUSTER} --region ${REGION})")
	done
	
	if [ ${ENVIRONMENT} == 'preproduction' ]; then
		FAMILY="-${CONTAINER}"
	fi
	case "${CONTAINER}" in
		'web')
			if [ ${ENVIRONMENT} == 'preproduction' ]; then
				CONTAINERNAME=web
			else
				CONTAINERNAME=WebWorker
			fi
		;;
		'cron')
			CONTAINERNAME=CronWorker
		;;
		'sidekiq')
			CONTAINERNAME=SidekiqWorker
		;;
		*)
			echo "You must set web,cron or sidekiq as container family! Exiting..."
			exit 1
		;;
	esac
	
	#Get the task id corresponding to the desired container
	if [ ${CONTAINERNAME} = "web" ]; then
		servicename=WebWorker
	else
		servicename=${CONTAINERNAME}
	fi

	index=0
	if [ -n "${services[1]}" ]; then
		#more than one service, they are named after their container
		while true; do
			[ "$(echo ${services[$index]} | jq -r '.services[].serviceName')" = "cr-${ENVIRONMENT}" ] && break
			[ "$(echo ${services[$index]} | jq -r '.services[].serviceName')" = "${servicename}" ] && break
			((index+=1))
		done
	fi
	SERVICE=${services[$index]}
	deployment_id=$(echo ${SERVICE} | jq -r '.services[].deployments[] | select(.status=="PRIMARY") | .id')
	TASKID=$(aws ecs list-tasks --cluster ${CLUSTER} \
		--started-by ${deployment_id} \
		--desired-status RUNNING \
		--region ${REGION} | jq -r '.taskArns[]'| head -1)
	#Short version of the TASKID
	TID=$(echo ${TASKID}|cut -d"/" -f3)
	task_def_arn=$(echo ${SERVICE} | jq -r '.services[].deployments[] | select(.status=="PRIMARY") | .taskDefinition')
	TASKDEF=$(aws ecs describe-task-definition --task-definition ${task_def_arn})
	CONFIG_FILE=$(echo ${TASKDEF} |
		jq -r ".taskDefinition.containerDefinitions[]| select(.name==\"${CONTAINERNAME}\") | .environmentFiles[].value" |
		cut -d":" -f6)
}


#First check if all the required utilities are present
check_requisites

#Then check if we are logged in
eval $(saml2aws script) &>/dev/null

#Parse command line options
TEMP=$(getopt -o 'e:c:h:f' --long 'environment:,container:,help,follow' -n '5ocr-tool' -- "$@")

if [ $? -ne 0 ]; then
	echo 'Terminating...' >&2
	exit 1
fi

eval set -- "$TEMP"
unset TEMP

while true; do
	case "$1" in
		'-e'|'--environment')
			ENVIRONMENT=$2
			shift 2
			continue
		;;
		'-c'|'--container')
			CONTAINER=$2
			shift 2
			continue
		;;
		'-f'|'--follow')
			shift 1
			FOLLOW="--follow"
			continue
		;;
		'-h'|'--help')
			shift 1
			usage
			exit 0
		;;
		'--')
			shift
			break
		;;
		*)
			usage
			exit 0
		;;
	esac
done

#Parse the main command
case "$1" in
	'login')
		do_login
	;;
	'ssh')
		check_login
		set_environment
		start_ssh
	;;
	'logs')
		check_login
		set_environment
		show_logs
	;;
	'config')
		check_login
		set_environment
		tmpfile=$(mktemp)
		get_config ${tmpfile}
		cat ${tmpfile}
		rm -f ${tmpfile}
	;;
	'config:set')
		check_login
		set_environment
		tmpfile=$(mktemp)
		get_config ${tmpfile}
		set_config ${tmpfile} "$@"
		rm -f ${tmpfile}
	;;
	'db:connect')
		check_login
		set_environment
		tmpfile=$(mktemp)
		get_config ${tmpfile}
		eval $(grep DATABASE_URL ${tmpfile})
		rm -f ${tmpfile}
		connect_db ${DATABASE_URL}
	;;
	*)
		usage
		exit 1
	;;
esac

